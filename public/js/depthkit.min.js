!function i(s,a,l){function p(n,e){if(!a[n]){if(!s[n]){var t="function"==typeof require&&require;if(!e&&t)return t(n,!0);if(c)return c(n,!0);var o=new Error("Cannot find module '"+n+"'");throw o.code="MODULE_NOT_FOUND",o}var r=a[n]={exports:{}};s[n][0].call(r.exports,function(e){var t=s[n][1][e];return p(t||e)},r,r.exports,i,s,a,l)}return a[n].exports}for(var c="function"==typeof require&&require,e=0;e<l.length;e++)p(l[e]);return p}({1:[function(e,t,n){t.exports=function(e){"string"==typeof e&&(e=[e]);for(var t=[].slice.call(arguments,1),n=[],o=0;o<e.length-1;o++)n.push(e[o],t[o]||"");return n.push(e[o]),n.join("")}},{}],2:[function(e,t,n){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var o="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},i=function(){function o(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(e,t,n){return t&&o(e.prototype,t),n&&o(e,n),e}}();var s=e("glslify"),r=function(e){function r(){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,r);var e=function(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}(this,(r.__proto__||Object.getPrototypeOf(r)).call(this));return e.manager=new THREE.LoadingManager,e.video=document.createElement("video"),e.video.id="depthkit-video",e.video.crossOrigin="anonymous",e.video.setAttribute("crossorigin","anonymous"),e.video.setAttribute("webkit-playsinline","webkit-playsinline"),e.video.setAttribute("playsinline","playsinline"),e.video.autoplay=!1,e.video.loop=!1,e.meshScalar=2,(r._instanceMesh=null)==r._geometryLookup&&(r._geometryLookup={}),e}return function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}(r,THREE.Object3D),i(r,[{key:"setMeshScalar",value:function(e){3<e&&(e=3),e<0&&(e=0);var t=Math.pow(2,Math.floor(e));this.meshScalar!=t&&(this.meshScalar=t,this.buildGeometry())}},{key:"buildGeometry",value:function(){var e=this.props.textureWidth/this.meshScalar+1,t=this.props.textureHeight/this.meshScalar+1,n=void 0;if(this.geometryBufferExistsInLookup(e*t)?n=r._geometryLookup[e*t]:(n=this.createGeometryBuffer(e,t),r._geometryLookup[e*t]=n),null==this._instanceMesh){this._instanceMesh=new THREE.Mesh(n,this._material),this._instanceMesh.frustumCulled=!1;var o=new THREE.Object3D;o.frustumCulled=!1,o.position.z=-(this.props.farClip-this.props.nearClip)/2-this.props.nearClip,this.add(o),o.add(this._instanceMesh)}else this._instanceMesh.geometry=n}},{key:"createGeometryBuffer",value:function(e,t){for(var n=new THREE.Vector2(this.meshScalar/this.props.textureWidth,this.meshScalar/this.props.textureHeight),o=new THREE.Geometry,r=0;r<t;r++)for(var i=0;i<e;i++)o.vertices.push(new THREE.Vector3(i*n.x,r*n.y,0));for(var s=0;s<t-1;s++)for(var a=0;a<e-1;a++)o.faces.push(new THREE.Face3(a+s*e,a+(s+1)*e,a+1+s*e)),o.faces.push(new THREE.Face3(a+1+s*e,a+(s+1)*e,a+1+(s+1)*e));return o}},{key:"geometryBufferExistsInLookup",value:function(e){for(var t in Object.keys(r._geometryLookup))if(e===t)return!0;return!1}},{key:"buildMaterial",value:function(){var e=s(["#extension GL_OES_standard_derivatives : enable\n#define GLSLIFY 1\n\nuniform sampler2D map;\nuniform float opacity;\nuniform float width;\nuniform float height;\n\nvarying vec2 vUv;\nvarying vec2 vUvDepth;\nvarying vec4 vPos;\nfloat _DepthBrightnessThreshold = 0.8;  // per-pixel brightness threshold, used to refine edge geometry from eroneous edge depth samples\nfloat _SheerAngleThreshold = 0.04;       // per-pixel internal edge threshold (sheer angle of geometry at that pixel)\n#define BRIGHTNESS_THRESHOLD_OFFSET 0.01\n#define FLOAT_EPS 0.00001\n#define CLIP_EPSILON 0.005\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + FLOAT_EPS)), d / (q.x + FLOAT_EPS), q.x);\n}\n\nfloat depthForPoint(vec2 texturePoint)\n{   \n    vec2 centerpix = vec2(.5/width, .5/height);\n    texturePoint += centerpix;\n    // clamp to texture bounds - 0.5 pixelsize so we do not sample outside our texture\n    texturePoint = clamp(texturePoint, centerpix, vec2(1.0, 0.5) - centerpix);\n    vec4 depthsample = texture2D(map, texturePoint);\n    vec3 depthsamplehsv = rgb2hsv(depthsample.rgb);\n    return depthsamplehsv.b > _DepthBrightnessThreshold + BRIGHTNESS_THRESHOLD_OFFSET ? depthsamplehsv.r : 0.0;\n}\n\nvoid main()\n{\n    vec2 centerpix = vec2(.5/width, .5/height);\n    vec2 centerDepthSampleCoord = vUvDepth - mod(vUvDepth, vec2(1.0/width, 1.0/height) ); // clamp to start of pixel\n\n    float depth = depthForPoint(centerDepthSampleCoord);\n    // we filter the _SheerAngleThreshold value on CPU so that we have an ease in over the 0..1 range, removing internal geometry at grazing angles\n    // we also apply near and far clip clipping, the far clipping plane is pulled back to remove geometry wrapped to the far plane from the near plane\n    //convert back from worldspace to local space\n    vec4 localPos = vPos;\n    //convert to homogenous coordinate space\n    localPos.xy /= localPos.z;\n    //find local space normal for triangle surface\n    vec3 dx = dFdx(localPos.xyz);\n    vec3 dy = dFdy(localPos.xyz);\n    vec3 n = normalize(cross(dx, dy));\n    \n    // make sure to handle dot product of the whole hemisphere by taking the absolute of range -1 to 0 to 1\n    float sheerAngle = abs(dot(n, vec3(0.0, 0.0, 1.0)));\n\n    // clamp to texture bounds - 0.5 pixelsize so we do not sample outside our texture\n    vec2 colorTexCoord = clamp(vUv, vec2(0.0, 0.5) + centerpix, vec2(1.0, 1.0) - centerpix);\n    vec4 color = texture2D(map, colorTexCoord);\n    color.w = opacity;\n\n    //color.xyz = vPos.xyz * 0.5 + 0.5;\n    //color.xyz = n.xyz * 0.5 + 0.5;\n    //color.xyz = vec3(sheerAngle, sheerAngle, sheerAngle);\n\n    if ( depth <        CLIP_EPSILON  ||\n         depth > (1.0 - CLIP_EPSILON) ||\n         sheerAngle < (_SheerAngleThreshold + FLOAT_EPS))\n    {\n        discard;\n    }\n\n    gl_FragColor = color;\n}"]),t=s(["#define GLSLIFY 1\nuniform float nearClip;\nuniform float farClip;\nuniform float width;\nuniform float height;\nuniform bool isPoints;\nuniform float pointSize;\nuniform float time;\nuniform vec2 focalLength;\nuniform vec2 principalPoint;\nuniform vec2 imageDimensions;\nuniform vec4 crop;\nuniform float meshScalar;\nuniform mat4 extrinsics;\nuniform sampler2D map;\nvarying vec4 vPos;\nvarying vec2 vUv;\nvarying vec2 vUvDepth;\n\nfloat _DepthBrightnessThreshold = 0.5;  // per-pixel brightness threshold, used to refine edge geometry from eroneous edge depth samples\n#define BRIGHTNESS_THRESHOLD_OFFSET 0.01\n#define FLOAT_EPS 0.00001\n#define CLIP_EPSILON 0.005\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + FLOAT_EPS)), d / (q.x + FLOAT_EPS), q.x);\n}\n\nfloat depthForPoint(vec2 texturePoint)\n{   \n    vec2 centerpix = vec2(1.0/width, 1.0/height) * 0.5;\n    texturePoint += centerpix;\n\n    // clamp to texture bounds - 0.5 pixelsize so we do not sample outside our texture\n    texturePoint = clamp(texturePoint, centerpix, vec2(1.0, 0.5) - centerpix);\n    vec4 depthsample = texture2D(map, texturePoint);\n    vec3 depthsamplehsv = rgb2hsv(depthsample.rgb);\n    return depthsamplehsv.b > _DepthBrightnessThreshold + BRIGHTNESS_THRESHOLD_OFFSET ? depthsamplehsv.r : 0.0;\n}\n\nvoid main()\n{\n    vec4 texSize = vec4(1.0 / width, 1.0 / height, width, height);\n    vec2 basetex = position.xy;\n\n    // we align our depth pixel centers with the center of each quad, so we do not require a half pixel offset\n    vec2 depthTexCoord = basetex * vec2(1.0, 0.5);\n    vec2 colorTexCoord = basetex * vec2(1.0, 0.5) + vec2(0.0, 0.5);\n\n    // coordinates are always aligned to a multiple of texture sample widths, no need to clamp to topleft\n    // unlike per-pixel sampling.\n    float depth = depthForPoint(depthTexCoord);\n    if (depth <= CLIP_EPSILON || ((1.0 - CLIP_EPSILON) >= depth))\n    {\n        // we use a 3x3 kernel, so sampling 8 neighbors\n        //vec2 textureStep = 1.0 / meshScalar;\n        vec2 textureStep = vec2(texSize.x * meshScalar, texSize.y * meshScalar);   // modify our texture step \n        \n        vec2 neighbors[8];\n        neighbors[0] = vec2(-textureStep.x, -textureStep.y);\n        neighbors[1] = vec2(0, -textureStep.y);\n        neighbors[2] = vec2(textureStep.x, -textureStep.y);\n        neighbors[3] = vec2(-textureStep.x, 0);\n        neighbors[4] = vec2(textureStep.x, 0);\n        neighbors[5] = vec2(-textureStep.x, textureStep.y);\n        neighbors[6] = vec2(0, textureStep.y);\n        neighbors[7] = vec2(textureStep.x, textureStep.y);\n        \n        // if this depth sample is not valid then check neighbors\n        int validNeighbors = 0;\n        float maxDepth = 0.0;\n        for (int i = 0; i < 8; i++)\n        {\n            float depthNeighbor = depthForPoint(depthTexCoord + neighbors[i]);\n            maxDepth = max(maxDepth, depthNeighbor);\n            validNeighbors += (depthNeighbor > CLIP_EPSILON || ((1.0 - CLIP_EPSILON) < depthNeighbor)) ? 1 : 0;\n        }\n\n        // clip to near plane if we and all our neighbors are invalid\n        depth = validNeighbors > 0 ? maxDepth : 0.0;\n    }\n\n    vec2 imageCoordinates = crop.xy + (basetex * crop.zw);\n    float z = depth * (farClip - nearClip) + nearClip; // transform from 0..1 space to near-far space Z\n    vec2 ortho = imageCoordinates * imageDimensions - principalPoint;\n    vec2 proj = ortho * z / focalLength;\n    vec4 worldPos = extrinsics *  vec4(proj.xy, z, 1.0);\n    worldPos.w = 1.0;\n    gl_Position =  projectionMatrix * modelViewMatrix * worldPos;\n    vUv = colorTexCoord;\n    vUvDepth = depthTexCoord;\n    vPos = worldPos;//gl_Position.xyz;//(modelMatrix * vec4(gl_Position.xyz, 1.0)).xyz;//(modelMatrix * vec4(position, 1.0)).xyz;\n}\n"]),n=new THREE.Matrix4,o=this.props.extrinsics;n.set(o.e00,o.e10,o.e20,o.e30,o.e01,o.e11,o.e21,o.e31,o.e02,o.e12,o.e22,o.e32,o.e03,o.e13,o.e23,o.e33);var r=new THREE.Matrix4;r.getInverse(n),this._material=new THREE.ShaderMaterial({uniforms:{map:{type:"t",value:this.videoTexture},time:{type:"f",value:0},nearClip:{type:"f",value:this.props.nearClip},farClip:{type:"f",value:this.props.farClip},meshScalar:{type:"f",value:this.meshScalar},focalLength:{value:this.props.depthFocalLength},principalPoint:{value:this.props.depthPrincipalPoint},imageDimensions:{value:this.props.depthImageSize},extrinsics:{value:n},extrinsicsInv:{value:r},crop:{value:this.props.crop},width:{type:"f",value:this.props.textureWidth},height:{type:"f",value:this.props.textureHeight},opacity:{type:"f",value:1}},vertexShader:t,fragmentShader:e,transparent:!0}),this._material.side=THREE.DoubleSide}},{key:"loadVideo",value:function(e){this.video.src=e,this.video.load()}},{key:"createVideoTexture",value:function(){var e=new THREE.VideoTexture(this.video);return e.minFilter=THREE.NearestFilter,e.magFilter=THREE.LinearFilter,e.format=THREE.RGBFormat,e.generateMipmaps=!1,e}},{key:"load",value:function(e,t,n,o){var r=this;if(this.loadVideo(t),this.videoTexture=this.createVideoTexture(),this.isJson(e)){var i=JSON.parse(e);this.setProps(i),this.createMesh(),n&&n(this)}else this.loadPropsFromFile(e).then(function(e){r.setProps(e),r.createMesh(),n&&n(r)}).catch(function(e){o?o(e):console.error(e)})}},{key:"createMesh",value:function(){this.buildMaterial(),this.buildGeometry(),this.children[0].frustumCulled=!1,this.children[0].name="depthkit"}},{key:"loadPropsFromFile",value:function(o){var r=this;return new Promise(function(t,n){var e=new THREE.FileLoader(r.manager);e.setResponseType("json"),e.load(o,function(e){t(e)},null,function(e){n(e)})})}},{key:"isJson",value:function(e){e="string"!=typeof e?JSON.stringify(e):e;try{e=JSON.parse(e)}catch(e){return!1}return"object"===(void 0===e?"undefined":o(e))&&null!==e}},{key:"setProps",value:function(e){this.props=e,null!=this.props.textureWidth&&null!=this.props.textureHeight||(this.props.textureWidth=this.props.depthImageSize.x,this.props.textureHeight=2*this.props.depthImageSize.y),null==this.props.extrinsics&&(this.props.extrinsics={e00:1,e01:0,e02:0,e03:0,e10:0,e11:1,e12:0,e13:0,e20:0,e21:0,e22:1,e23:0,e30:0,e31:0,e32:0,e33:1}),null==this.props.crop&&(this.props.crop={x:0,y:0,z:1,w:1})}},{key:"setOpacity",value:function(e){this._material.uniforms.opacity.value=e}},{key:"play",value:function(){this.video.isPlaying?console.warn("Can not play because the character is already playing"):this.video.play()}},{key:"stop",value:function(){this.video.currentTime=0,this.video.pause()}},{key:"pause",value:function(){this.video.pause()}},{key:"setLoop",value:function(e){this.video.loop=e}},{key:"setVolume",value:function(e){this.video.volume=e}},{key:"update",value:function(e){this._material.uniforms.time.value=e}},{key:"dispose",value:function(){try{this.mesh.parent.remove(this.mesh)}catch(e){console.warn(e)}finally{this.mesh.traverse(function(e){void 0!==e.geometry&&(e.geometry.dispose(),e.material.dispose())})}}}]),r}();n.default=r},{glslify:1}],3:[function(e,t,n){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.Depthkit=void 0;var o,r="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},i=e("./depthkit"),s=(o=i)&&o.__esModule?o:{default:o};"undefined"!=typeof window&&"object"===r(window.THREE)?window.Depthkit=s.default:console.warn("[Depthkit.js] It seems like THREE is not included in your code, try including it before Depthkit.js"),n.Depthkit=s.default},{"./depthkit":2}]},{},[3]);
